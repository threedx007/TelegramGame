import { useState, useCallback, useEffect } from 'react';
import { GameState, Player, Obstacle, Bonus, Particle, EducationalMessage } from '@/types/game';

const EDUCATIONAL_MESSAGES: Record<string, EducationalMessage> = {
  fat: { emoji: 'üßà', title: '–ñ–∏—Ä–æ–≤–∞—è –ø—Ä–æ–±–∫–∞!', text: '–ù–µ —Å–ª–∏–≤–∞–π—Ç–µ –∂–∏—Ä –≤ —Å–µ–ø—Ç–∏–∫! –≠—Ç–æ –æ—Å–Ω–æ–≤–Ω–∞—è –ø—Ä–∏—á–∏–Ω–∞ –∑–∞—Å–æ—Ä–æ–≤.' },
  waste: { emoji: 'üóëÔ∏è', title: '–¢–≤–µ—Ä–¥—ã–µ –æ—Ç—Ö–æ–¥—ã!', text: '–¢–≤–µ—Ä–¥—ã–µ –æ—Ç—Ö–æ–¥—ã –∑–∞—Å–æ—Ä—è—é—Ç —Å–∏—Å—Ç–µ–º—É –∏ –Ω–∞—Ä—É—à–∞—é—Ç —Ä–∞–±–æ—Ç—É —Å–µ–ø—Ç–∏–∫–∞.' },
  chemical: { emoji: 'üß™', title: '–•–∏–º–∏—á–µ—Å–∫–æ–µ –∑–∞–≥—Ä—è–∑–Ω–µ–Ω–∏–µ!', text: '–ë—ã—Ç–æ–≤–∞—è —Ö–∏–º–∏—è —É–±–∏–≤–∞–µ—Ç –ø–æ–ª–µ–∑–Ω—ã–µ –±–∞–∫—Ç–µ—Ä–∏–∏ –≤ —Å–µ–ø—Ç–∏–∫–µ.' },
  ice: { emoji: 'üßä', title: '–ó–∞–º–µ—Ä–∑–∞–Ω–∏–µ!', text: '–£—Ç–µ–ø–ª–∏—Ç–µ —Å–µ–ø—Ç–∏–∫ –Ω–∞ –∑–∏–º—É, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∑–∞–º–µ—Ä–∑–∞–Ω–∏—è.' },
  lightning: { emoji: '‚ö°', title: '–≠–ª–µ–∫—Ç—Ä–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–±–ª–µ–º—ã!', text: '–†–µ–≥—É–ª—è—Ä–Ω–æ –ø—Ä–æ–≤–µ—Ä—è–π—Ç–µ –∫–æ–º–ø—Ä–µ—Å—Å–æ—Ä –∏ —ç–ª–µ–∫—Ç—Ä–æ–æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–µ.' },
  roots: { emoji: 'üå≥', title: '–ö–æ—Ä–Ω–∏ –¥–µ—Ä–µ–≤—å–µ–≤!', text: '–ù–µ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–π—Ç–µ —Å–µ–ø—Ç–∏–∫ —Ä—è–¥–æ–º —Å –±–æ–ª—å—à–∏–º–∏ –¥–µ—Ä–µ–≤—å—è–º–∏.' }
};

export function useGameState() {
  const [gameState, setGameState] = useState<GameState>({
    state: 'start',
    score: 0,
    distance: 0,
    level: 1,
    combo: 0,
    gameSpeed: 2,
    bestScore: parseInt(localStorage.getItem('septicSurferBest') || '0')
  });

  const [player, setPlayer] = useState<Player>({
    x: 50,
    y: window.innerHeight - 150, // –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –Ω–∞ –∑–µ–º–ª–µ
    width: 40,
    height: 40,
    velocityY: 0,
    grounded: true,
    color: '#00A8FF'
  });

  const [obstacles, setObstacles] = useState<Obstacle[]>([]);
  const [bonuses, setBonuses] = useState<Bonus[]>([]);
  const [particles, setParticles] = useState<Particle[]>([]);
  const [educationalMessage, setEducationalMessage] = useState<EducationalMessage | null>(null);
  const [showCombo, setShowCombo] = useState(false);
  const [lastBonusTime, setLastBonusTime] = useState<number>(0);

  const resetGame = useCallback(() => {
    setGameState(prev => ({
      ...prev,
      state: 'playing',
      score: 0,
      distance: 0,
      level: 1,
      combo: 0,
      gameSpeed: 2
    }));

    setPlayer({
      x: 50,
      y: window.innerHeight - 150, // –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –Ω–∞ –∑–µ–º–ª–µ
      width: 40,
      height: 40,
      velocityY: 0,
      grounded: true,
      color: '#00A8FF'
    });

    setObstacles([]);
    setBonuses([]);
    setParticles([]);
    setEducationalMessage(null);
    setShowCombo(false);
  }, []);

  const pauseGame = useCallback(() => {
    setGameState(prev => ({ ...prev, state: 'paused' }));
  }, []);

  const resumeGame = useCallback(() => {
    setGameState(prev => ({ ...prev, state: 'playing' }));
  }, []);

  const gameOver = useCallback(() => {
    setGameState(prev => {
      const newBestScore = Math.max(prev.score, prev.bestScore);
      localStorage.setItem('septicSurferBest', newBestScore.toString());
      
      // Send score to Telegram if available
      if (window.Telegram?.WebApp) {
        window.Telegram.WebApp.sendData(JSON.stringify({
          score: prev.score,
          distance: Math.floor(prev.distance),
          timestamp: Date.now()
        }));
      }

      return {
        ...prev,
        state: 'gameOver',
        bestScore: newBestScore
      };
    });
  }, []);

  const collectBonus = useCallback((bonus: Bonus) => {
    console.log('Collecting bonus:', bonus, 'Game state before:', gameState.state);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∏–≥—Ä–∞ –≤—Å–µ –µ—â–µ –∏–¥–µ—Ç
    if (gameState.state !== 'playing') {
      console.log('Game not playing, ignoring bonus collection');
      return;
    }
    
    const now = Date.now();
    setLastBonusTime(now);
    
    setGameState(prev => {
      const newCombo = prev.combo + 1;
      const multiplier = Math.min(newCombo, 4);
      const points = bonus.value * multiplier;
      
      console.log('Bonus collected! Points:', points, 'Combo:', newCombo);
      
      if (newCombo > 1) {
        setShowCombo(true);
        setTimeout(() => setShowCombo(false), 2000);
      }

      return {
        ...prev,
        score: prev.score + points,
        combo: newCombo
      };
    });

    // Create particles
    const newParticles: Particle[] = [];
    for (let i = 0; i < 5; i++) {
      newParticles.push({
        x: bonus.x + bonus.width / 2,
        y: bonus.y + bonus.height / 2,
        vx: (Math.random() - 0.5) * 4,
        vy: (Math.random() - 0.5) * 4,
        size: 3,
        color: bonus.color,
        life: 30,
        maxLife: 30
      });
    }
    setParticles(prev => [...prev, ...newParticles]);
  }, [gameState.state]);

  const hitObstacle = useCallback((obstacle: Obstacle) => {
    const message = EDUCATIONAL_MESSAGES[obstacle.type];
    setEducationalMessage(message);
    setTimeout(() => gameOver(), 1000);
  }, [gameOver]);

  const shareScore = useCallback(() => {
    if (window.Telegram?.WebApp) {
      window.Telegram.WebApp.showPopup({
        title: '–ü–æ–¥–µ–ª–∏—Ç—å—Å—è',
        message: `–Ø –Ω–∞–±—Ä–∞–ª ${gameState.score} –æ—á–∫–æ–≤ –≤ –∏–≥—Ä–µ –°–µ–ø—Ç–∏–∫-–°–µ—Ä—Ñ–µ—Ä! –ü–æ–ø—Ä–æ–±—É–π –ø–æ–±–∏—Ç—å –º–æ–π —Ä–µ–∫–æ—Ä–¥!`,
        buttons: [
          { id: 'share', type: 'default', text: '–ü–æ–¥–µ–ª–∏—Ç—å—Å—è' },
          { type: 'cancel' }
        ]
      });
    }
  }, [gameState.score]);

  // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏–≥—Ä–æ–≤–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è (—Å–±—Ä–æ—Å –∫–æ–º–±–æ –ø–æ –≤—Ä–µ–º–µ–Ω–∏)
  const updateGameLogic = useCallback(() => {
    if (gameState.state === 'playing') {
      const now = Date.now();
      // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∫–æ–º–±–æ —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã –±–µ–∑ –±–æ–Ω—É—Å–æ–≤
      if (gameState.combo > 0 && lastBonusTime > 0 && now - lastBonusTime > 3000) {
        console.log('Resetting combo due to timeout');
        setGameState(prev => ({ ...prev, combo: 0 }));
        setLastBonusTime(0);
      }
    }
  }, [gameState.state, gameState.combo, lastBonusTime]);

  return {
    gameState,
    player,
    obstacles,
    bonuses,
    particles,
    educationalMessage,
    showCombo,
    setGameState,
    setPlayer,
    setObstacles,
    setBonuses,
    setParticles,
    setEducationalMessage,
    resetGame,
    pauseGame,
    resumeGame,
    gameOver,
    collectBonus,
    hitObstacle,
    shareScore,
    updateGameLogic
  };
}
